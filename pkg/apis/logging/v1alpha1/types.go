package v1alpha1

import (
	"bytes"
	"fmt"
	"github.com/operator-framework/operator-sdk/pkg/sdk"
	"github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"text/template"
)

// LoggingOperatorList auto generated by the sdk
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type LoggingOperatorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata"`
	Items           []LoggingOperator `json:"items"`
}

// LoggingOperator auto generated by the sdk
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type LoggingOperator struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata"`
	Spec              LoggingOperatorSpec   `json:"spec"`
	Status            LoggingOperatorStatus `json:"status,omitempty"`
}

// LoggingOperatorSpec holds the spec for the operator
type LoggingOperatorSpec struct {
	Input  Input    `json:"input"`
	Filter []Filter `json:"filter"`
	Output []Output `json:"output"`
}

// LoggingOperatorStatus holds the status info for the operator
type LoggingOperatorStatus struct {
	// Fill me
}

// Input this determines the log origin
type Input struct {
	Label map[string]string `json:"label"`
}

// Filter defines the filter plugins used by fluentd
// Todo validation to Format (Regexp) and TimeFormat
type Filter struct {
	Type       string `json:"type"`
	Format     string `json:"format"`
	TimeFormat string `json:"timeFormat"`
}

// filterTemplate for generating filters
// now only parse supported and tested
var filterTemplate = `
<filter {{ .pattern }}.** >
  @type {{ .type }}
  format {{ .format }}
  time_format {{ .timeFormat }}
  key_name log
</filter>
`

// Render the fluentd configuration for filter
func (f *Filter) Render(values map[string]string) (string, error) {
	t := template.New("filterTemplate")
	t, err := t.Parse(filterTemplate)
	if err != nil {
		return "", err
	}
	tpl := new(bytes.Buffer)
	err = t.Execute(tpl, values)
	if err != nil {
		return "", err
	}
	return tpl.String(), nil
}

// Output defines the output plugins used by fluentd
type Output struct {
	S3 *outputS3 `json:"s3"`
}

type outputS3 struct {
	Name       string      `json:"name"`
	Parameters []Parameter `json:"parameters"`
}

// GetMap get values from child Parameters
func (o *outputS3) GetMap() map[string]string {
	params := map[string]string{}
	for _, p := range o.Parameters {
		if p.ValueFrom != nil {
			value, err := p.ValueFrom.GetValue()
			if err != nil {
				logrus.Errorf("error getting value for %q: %s", p.Name, err.Error())
			}
			params[p.Name] = value
		} else {
			params[p.Name] = p.Value
		}
	}
	return params
}

// s3Template S3 Go template to generate configuration
var s3Template = `
<match {{ .pattern }}.** >
  @type s3

  aws_key_id {{ .aws_key_id }}
  aws_sec_key {{ .aws_sec_key }}
  s3_bucket {{ .s3_bucket }}
  s3_region {{ .s3_region }}

  path logs/${tag}/%Y/%m/%d/
  s3_object_key_format %{path}%{time_slice}_%{index}.%{file_extension}

  # if you want to use ${tag} or %Y/%m/%d/ like syntax in path / s3_object_key_format,
  # need to specify tag for ${tag} and time for %Y/%m/%d in <buffer> argument.
  <buffer tag,time>
    @type file
    path /buffers/s3
    timekey 3600 # 1 hour partition
    timekey_wait 10m
    timekey_use_utc true # use utc
  </buffer>
  <format>
    @type json
  </format>
</match>
`

// Render is parsing the template and generate fluentd config
func (o *outputS3) Render(values map[string]string) (string, error) {
	t := template.New("s3Template")
	t, err := t.Parse(s3Template)
	if err != nil {
		return "", err
	}
	tpl := new(bytes.Buffer)
	err = t.Execute(tpl, values)
	if err != nil {
		return "", err
	}
	return tpl.String(), nil
}

// Parameter generic parameter type to handle values from different sources
type Parameter struct {
	Name      string     `json:"name"`
	ValueFrom *ValueFrom `json:"valueFrom"`
	Value     string     `json:"value"`
}

// GetMap for filter template values
func (f *Filter) GetMap() map[string]string {
	params := map[string]string{}
	params["type"] = f.Type
	params["format"] = f.Format
	params["timeFormat"] = f.TimeFormat
	return params
}

// ValueFrom generic type to determine value origin
type ValueFrom struct {
	SecretKeyRef KubernetesSecret `json:"secretKeyRef"`
}

// GetValue handles the different origin of ValueFrom
func (vf *ValueFrom) GetValue() (string, error) {
	return vf.SecretKeyRef.GetValue()
}

// KubernetesSecret is a ValueFrom type
type KubernetesSecret struct {
	Name string `json:"name"`
	Key  string `json:"key"`
}

// GetValue implement GetValue interface
func (ks KubernetesSecret) GetValue() (string, error) {
	secret := corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Namespace: "default",
			Name:      ks.Name,
		},
	}
	err := sdk.Get(&secret)
	if err != nil {
		return "", err
	}
	value, ok := secret.Data[ks.Key]
	if !ok {
		return "", fmt.Errorf("key %q not found in secret %q ", ks.Key, ks.Name)
	}
	return string(value), nil
}
